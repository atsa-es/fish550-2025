{
  "hash": "fb860fd1ec9a0adf413ea1df7245bafc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Lab Intro\nsubtitle: \"Lab 2 Analyzing multivariate salmon data\"\nauthor: \"E Holmes\"\ndate: \"April 13, 2023\"\noutput:\n  pdf_document:\n    toc: yes\n  html_document:\n    code-folding: yes\n    toc: yes\n    toc_float: yes\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\noptions(dplyr.summarise.inform = FALSE)\n```\n:::\n\n\n\n\nFor this lab you will use multivariate auto-regressive state-space (MARSS) to analyze multivariate salmon data from the Columbia River. These data are noisy and gappy. They are estimates of total spawner abundance and might include hatchery spawners.\n\n## Teams\n\n1. Lower Columbia River Chinook: Zoe Rand (QERM), Emma Timmins-Schiffman (Genome Sci), Maria Kuruvilla (QERM)\n2. Lower Columbia River Steelhead: Eric French (Civil), Liz Elmstrom (SAFS), Terrance Wang (SAFS)\n3. Lower Columbia River Coho: Nick Chambers (SAFS), Karl Veggerby (SAFS), Miranda Mudge (Molecular & Cellular)\n4. Middle Columbia River Steelhead: Madison Shipley (SAFS), Dylan Hubl (Env & Forest Sci)\n\n## Lower Columbia River salmon spawner data\n\nThese data are from the [Coordinated Assessments Partnership (CAP) ](https://www.streamnet.org/cap/about-cap/) and downloaded using the [rCAX R client](https://nwfsc-math-bio.github.io/rCAX/) for the CAX (the CAP database) API. The data are saved in `Lab-2/Data_Images/columbia-river.rda`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(here::here(\"Lab-2\", \"Data_Images\", \"columbia-river.rda\"))\n```\n:::\n\n\n\n\nThe data set has data for fi endangered and threatened ESU (Evolutionary Significant Units) in the Lower Columbia River.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nesu <- unique(columbia.river$esu_dps)\nesu\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Steelhead (Middle Columbia River DPS)\"     \n[2] \"Steelhead (Upper Columbia River DPS)\"      \n[3] \"Steelhead (Lower Columbia River DPS)\"      \n[4] \"Salmon, coho (Lower Columbia River ESU)\"   \n[5] \"Salmon, Chinook (Lower Columbia River ESU)\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Figure from ESA recovery plan for Lower Columbia River Coho salmon, Lower Columbia River Chinook salmon, Columbia River Chum salmon, and Lower Columbia River steelhead. 2013. NMFS NW Region.  https://repository.library.noaa.gov/view/noaa/16002](Data_Images/LCR-chinook-regions.png){width=50%}\n:::\n:::\n\n\n\n\n### Data structure\n\nThe dataset has the following columns\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(columbia.river)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"species\"       \"esu_dps\"       \"majorpopgroup\" \"esapopname\"   \n[5] \"commonpopname\" \"run\"           \"spawningyear\"  \"value\"        \n[9] \"value_type\"   \n```\n\n\n:::\n:::\n\n\n\n* species: Chinook, Coho, Steelhead\n* esu_dps: name of the ESU\n* majorpopgroup: biological major group\n* commonpopname: common population name, generally a stream or river\n* run: run-timing\n* spawningyear: the year that the spawners were counted on the spawning grounds\n* value: total (natural-born and hatchery-born) spawners on the spawning ground. Generally some type of redd-count expansion or some other stream count of spawners. Redd = a gravel nest.\n\n### Data plots\n\nLet's load one ESU and make a plot. Create a function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotesu <- function(esuname){\n  df <- columbia.river %>% subset(esu_dps %in% esuname)\nggplot(df, aes(x=spawningyear, y=log(value), color=majorpopgroup)) + \n  geom_point(size=0.2, na.rm = TRUE) + \n  theme(strip.text.x = element_text(size = 3)) +\n  theme(axis.text.x = element_text(size = 5, angle = 90)) +\n  facet_wrap(~esapopname) +\n  ggtitle(paste0(esuname, collapse=\"\\n\"))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplotesu(esu[3])\n```\n\n::: {.cell-output-display}\n![](Lab2-MARSS_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplotesu(esu[4])\n```\n\n::: {.cell-output-display}\n![](Lab2-MARSS_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplotesu(esu[5])\n```\n\n::: {.cell-output-display}\n![](Lab2-MARSS_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplotesu(esu[1])\n```\n\n::: {.cell-output-display}\n![](Lab2-MARSS_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- columbia.river %>% subset(species == \"Chinook salmon\")\nggplot(df, aes(x=spawningyear, y=log(value), color=run)) + \n  geom_point(size=0.2, na.rm = TRUE) +\n  theme(strip.text.x = element_text(size = 3)) +\n  theme(axis.text.x = element_text(size = 5, angle = 90)) + \n  facet_wrap(~esapopname)\n```\n\n::: {.cell-output-display}\n![](Lab2-MARSS_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\n## Tasks for each group\n\n1. Create estimates of spawner abundance for all missing years and provide estimates of the decline from the historical abundance.\n\n2. Evaluate support for the major population groups. Are the populations in the groups more correlated than outside the groups?\n\n3. Evaluate the evidence of cycling in the data. *We will talk about how to do this on the Tuesday after lab.*\n\n\n### Tips\n\n**Simplify**\n\nIf your ESU has many populations, start with a smaller set of 4-7 populations.\n\n**Assumptions**\n\nYou can assume that `R=\"diagonal and equal\"` and `A=\"scaling\"`. Assume that \"historical\" means the earliest years available for your group.\n\n**States**\n\nYour abundance estimate is the \"x\" or \"state\" estimates. You can get this from\n```\nfit$states\n```\nor \n```\ntsSmooth(fit)\n```\nwhere `fit` is from `fit <- MARSS()`\n\n**plotting**\n\nEstimate of the mean of the spawner counts based on your x model.\n```\nautoplot(fit, plot.type=\"fitted.ytT\")\n```\n\n**diagnostics**\n```\nautoplot(fit, plot.type=\"residuals\")\n```\n\n### Address the following in your methods\n\n* Describe your assumptions about the x and how the data time series are related to x.\n\n   - How are the x and y (data) related? 1 x for 1 y or will you assume 1 x for all y or 1 x for each major population group? How will you choose? \n   - What will you assume about the U for the x's?\n   - What will you assume about the Q matrix?\n   \n* Write out your assumptions as different models **in matrix form**, fit each and then compare these with AIC or AICc.\n\n* Do your estimates differ depending on the assumptions you make about the structure of the data, i.e. you assumptions about the x's, Q, and U.\n\n## Sample code\n\nHere I show how I might analyze the Upper Columbia Steelhead data.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Figure from 2022 5-Year Review: Summary & Evaluation of Upper Columbia River Spring-run Chinook Salmon and Upper Columbia River Steelhead. NMFS. West Coast Region. https://doi.org/10.25923/p4w5-dp31](Data_Images/UCR-Steelhead-regions.png){width=50%}\n:::\n:::\n\n\n\n\nSet up the data. We need the time series in a matrix with time across the columns.\n\nLoad the data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(here::here(\"Lab-2\", \"Data_Images\", \"columbia-river.rda\"))\n```\n:::\n\n\n\n\nWrangle the data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nesuname <- esu[2]\n\ndat <- columbia.river %>% \n  subset(esu_dps == esuname) %>% # get only this ESU\n  mutate(log.spawner = log(value)) %>% # create a column called log.spawner\n  select(esapopname, spawningyear, log.spawner) %>% # get just the columns that I need\n  pivot_wider(names_from = \"esapopname\", values_from = \"log.spawner\") %>% \n  column_to_rownames(var = \"spawningyear\") %>% # make the years rownames\n  as.matrix() %>% # turn into a matrix with year down the rows\n  t() # make time across the columns\n# MARSS complains if I don't do this\ndat[is.na(dat)] <- NA\n```\n:::\n\n\n\n\nClean up the row names\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp <- rownames(dat)\ntmp <- stringr::str_replace(tmp, \"Steelhead [(]Upper Columbia River DPS[)]\", \"\")\ntmp <- stringr::str_replace(tmp, \"River - summer\", \"\")\ntmp <- stringr::str_trim(tmp)\nrownames(dat) <- tmp\n```\n:::\n\n\n\n\nSpecify a model\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod.list1 <- list(\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  Q = \"unconstrained\"\n)\n```\n:::\n\n\n\n\nFit the model. In this case, a BFGS algorithm is faster.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MARSS)\nfit1 <- MARSS(dat, model=mod.list1, method=\"BFGS\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSuccess! Converged in 76 iterations.\nFunction MARSSkfas used for likelihood calculation.\n\nMARSS fit is\nEstimation method: BFGS \nEstimation converged in 76 iterations. \nLog-likelihood: -109.4078 \nAIC: 256.8155   AICc: 262.1676   \n \n               Estimate\nR.diag          0.00997\nU.X.Entiat      0.02182\nU.X.Methow      0.01852\nU.X.Okanogan    0.00140\nU.X.Wenatchee  -0.02222\nQ.(1,1)         0.28016\nQ.(2,1)         0.12303\nQ.(3,1)         0.14275\nQ.(4,1)         0.23415\nQ.(2,2)         0.31642\nQ.(3,2)         0.30806\nQ.(4,2)         0.19061\nQ.(3,3)         0.31031\nQ.(4,3)         0.18852\nQ.(4,4)         0.52813\nx0.X.Entiat     4.61647\nx0.X.Methow     6.43401\nx0.X.Okanogan   6.47217\nx0.X.Wenatchee  8.04868\nInitial states (x0) defined at t=0\n\nStandard errors have not been calculated. \nUse MARSSparamCIs to compute CIs and bias estimates.\n```\n\n\n:::\n:::\n\n\n\n\nHmmmmm, the Q variance is so high that it perfectly fits the data. That doesn't seem right.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(fit1, plot.type=\"fitted.ytT\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMARSSresiduals.tT reported warnings. See msg element or attribute of returned residuals object.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Lab2-MARSS_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n\nLet's look at the corrplot. Interesting. The Methow and Entiat are almost perfectly correlated while the Entiat and Wenatchee are somewhat correlated. That makes sense if you look at a map.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(corrplot)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ncorrplot 0.95 loaded\n```\n\n\n:::\n\n```{.r .cell-code}\nQ <- coef(fit1, type=\"matrix\")$Q\ncorrmat <- diag(1/sqrt(diag(Q))) %*% Q %*% diag(1/sqrt(diag(Q)))\ncorrplot(corrmat)\n```\n\n::: {.cell-output-display}\n![](Lab2-MARSS_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n\nI need to use the EM algorithm (remove `method=\"BFGS\"`) because the BFGS algorithm doesn't allow constraints on the Q matrix.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod.list2 <- list(\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  Q = \"equalvarcov\"\n)\nfit2 <- MARSS(dat, model=mod.list2, control = list(maxit=1000))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSuccess! abstol and log-log tests passed at 794 iterations.\nAlert: conv.test.slope.tol is 0.5.\nTest with smaller values (<0.1) to ensure convergence.\n\nMARSS fit is\nEstimation method: kem \nConvergence test: conv.test.slope.tol = 0.5, abstol = 0.001\nEstimation converged in 794 iterations. \nLog-likelihood: -120.6028 \nAIC: 263.2057   AICc: 264.9657   \n \n               Estimate\nR.diag           0.1290\nU.X.Entiat       0.0257\nU.X.Methow       0.0311\nU.X.Okanogan     0.0166\nU.X.Wenatchee   -0.0282\nQ.diag           0.2632\nQ.offdiag        0.2631\nx0.X.Entiat      4.2026\nx0.X.Methow      5.9042\nx0.X.Okanogan    5.8359\nx0.X.Wenatchee   8.0703\nInitial states (x0) defined at t=0\n\nStandard errors have not been calculated. \nUse MARSSparamCIs to compute CIs and bias estimates.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(fit2, plot.type=\"fitted.ytT\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMARSSresiduals.tT reported warnings. See msg element or attribute of returned residuals object.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Lab2-MARSS_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\n\n\nNow I want try something different. I will treat the Methow-Okanogan as one state and the Entiat-Wenatchee as another. I'll let these be correlated together. Interesting, these two are estimated to be perfectly correlated.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod.list3 <- mod.list1\nmod.list3$Q <- \"unconstrained\"\nmod.list3$Z <- factor(c(\"ew\", \"mo\", \"mo\", \"ew\"))\nfit3 <- MARSS(dat, model = mod.list3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWarning! Reached maxit before parameters converged. Maxit was 500.\n neither abstol nor log-log convergence tests were passed.\n\nMARSS fit is\nEstimation method: kem \nConvergence test: conv.test.slope.tol = 0.5, abstol = 0.001\nWARNING: maxit reached at  500  iter before convergence.\n Neither abstol nor log-log convergence test were passed.\n The likelihood and params are not at the MLE values.\n Try setting control$maxit higher.\nLog-likelihood: -137.532 \nAIC: 295.064   AICc: 296.5209   \n \n            Estimate\nA.Okanogan  -0.68779\nA.Wenatchee  1.54127\nR.diag       0.18062\nU.ew        -0.02175\nU.mo         0.00374\nQ.(1,1)      0.22050\nQ.(2,1)      0.22103\nQ.(2,2)      0.22164\nx0.ew        6.51468\nx0.mo        7.33795\nInitial states (x0) defined at t=0\n\nStandard errors have not been calculated. \nUse MARSSparamCIs to compute CIs and bias estimates.\n\nConvergence warnings\n Warning: the  logLik  parameter value has not converged.\n Type MARSSinfo(\"convergence\") for more info on this warning.\n```\n\n\n:::\n\n```{.r .cell-code}\nautoplot(fit3, plot.type=\"fitted.ytT\")\n```\n\n::: {.cell-output-display}\n![](Lab2-MARSS_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\n\nFinally, let's look at the AIC values. Fit1 was very flexible and can put a line through the data so I know I have at least one model in the set that can fit the data. Well, the most flexible model is the best. At this point, I'd like to look just at data after 1980 or so. I don't like the big dip that happened in the Wenatchee River. I'd want to talk to the biologists to find out what happened, especially because I know that there might be hatchery releases in this system.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naic <- c(fit1$AICc, fit2$AICc, fit3$AICc)\naic-min(aic)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  0.00000  2.79807 34.35331\n```\n\n\n:::\n:::\n\n\n\n\n### Including cycling\n\nLet's just look at the data after 1987 to eliminate that string of NAs in the 3 rivers.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat87 <- dat[,colnames(dat)>1987]\n```\n:::\n\n\n\n\nLet's look the acf to look for evidence of cycling. Due to the nature of their life-cycle where they tend to return back to their spawning grounds after a certain numbers of years, we might expect some cycling although steelhead aren't really known for this (unlike sockeye, chinook and pink).\n\nWell no obvious cycles.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(2,2))\nfor(i in 1:4){\n  acf(dat87[i,], na.action=na.pass, main=rownames(dat87)[i])\n}\n```\n\n::: {.cell-output-display}\n![](Lab2-MARSS_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\n\nBut let's go through how we might include cycles. We are going to include cycles with frequency 3, 4, and 5, choosem to reflect steelhead returning after 3, 4 or 5 years.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTT <- dim(dat87)[2] #number of time steps\ncovariates <- rbind(\n  forecast::fourier(ts(1:TT, freq=3), K=1) |> t(),\n  forecast::fourier(ts(1:TT, freq=4), K=1) |> t(),\n  forecast::fourier(ts(1:TT, freq=5), K=1) |> t()\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRegistered S3 method overwritten by 'quantmod':\n  method            from\n  as.zoo.data.frame zoo \n```\n\n\n:::\n:::\n\n\n\n\nNow let's fit a model with these covariates. Let's analyze the populations separately, so Q is diagonal.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod.list4 <- list(\n  Q = \"unconstrained\",\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  D = \"unconstrained\",\n  d = covariates\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfit4.87 <- MARSS(dat87, model=mod.list4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSuccess! abstol and log-log tests passed at 78 iterations.\nAlert: conv.test.slope.tol is 0.5.\nTest with smaller values (<0.1) to ensure convergence.\n\nMARSS fit is\nEstimation method: kem \nConvergence test: conv.test.slope.tol = 0.5, abstol = 0.001\nEstimation converged in 78 iterations. \nLog-likelihood: -55.48472 \nAIC: 196.9694   AICc: 238.5519   \n \n                   Estimate\nR.diag              0.00841\nU.X.Entiat         -0.01592\nU.X.Methow          0.00629\nU.X.Okanogan       -0.01331\nU.X.Wenatchee      -0.06327\nQ.(1,1)             0.21426\nQ.(2,1)             0.10446\nQ.(3,1)             0.12493\nQ.(4,1)             0.12760\nQ.(2,2)             0.21888\nQ.(3,2)             0.21364\nQ.(4,2)             0.13562\nQ.(3,3)             0.22037\nQ.(4,3)             0.13483\nQ.(4,4)             0.31566\nx0.X.Entiat         6.34777\nx0.X.Methow         7.39581\nx0.X.Okanogan       7.02470\nx0.X.Wenatchee      8.65239\nD.(Entiat,S1-3)    -0.03464\nD.(Methow,S1-3)    -0.12969\nD.(Okanogan,S1-3)  -0.11592\nD.(Wenatchee,S1-3) -0.01482\nD.(Entiat,C1-3)     0.02784\nD.(Methow,C1-3)    -0.08604\nD.(Okanogan,C1-3)  -0.09585\nD.(Wenatchee,C1-3)  0.05808\nD.(Entiat,S1-4)    -0.11286\nD.(Methow,S1-4)    -0.13983\nD.(Okanogan,S1-4)  -0.09480\nD.(Wenatchee,S1-4) -0.06365\nD.(Entiat,C1-4)     0.02030\nD.(Methow,C1-4)    -0.09692\nD.(Okanogan,C1-4)  -0.08208\nD.(Wenatchee,C1-4) -0.08237\nD.(Entiat,S1-5)    -0.19272\nD.(Methow,S1-5)     0.05745\nD.(Okanogan,S1-5)   0.07723\nD.(Wenatchee,S1-5) -0.18255\nD.(Entiat,C1-5)    -0.01818\nD.(Methow,C1-5)     0.17916\nD.(Okanogan,C1-5)   0.15510\nD.(Wenatchee,C1-5) -0.02965\nInitial states (x0) defined at t=0\n\nStandard errors have not been calculated. \nUse MARSSparamCIs to compute CIs and bias estimates.\n```\n\n\n:::\n:::\n\n\n\n\nLet's plot the estimates. `broom::tidy()` will get a data frame with the terms, estimates and CIs.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(broom)\n# get all the parameter estimates for D\ndf <- tidy(fit4.87) %>%\n  subset(stringr::str_sub(term,1,1)==\"D\")\n# add a column with the river names\ndf$river <- as.factor(rep(rownames(dat87),nrow(covariates)))\n# add a column for the lag or frequency\nlags <- stringr::str_split(rownames(covariates), \"-\") %>% lapply(function(x){x[[2]]}) %>% unlist()\ndf$lag <- rep(lags, each=nrow(dat87))\n# add column for the type of fourier\ndf$type <- rep(rownames(covariates), each=nrow(dat87))\n```\n:::\n\n\n\n\nWe can then plot this. Interesting. Some support for 5 year cycles.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x=type, y=estimate, col=lag)) + \n  geom_point() +\n  geom_errorbar(aes(ymin=conf.low, ymax=conf.up), width=.2, position=position_dodge(.9)) +\n  geom_hline(yintercept = 0) +\n  facet_wrap(~river) +\n  ggtitle(\"The cycle estimates with CIs\")\n```\n\n::: {.cell-output-display}\n![](Lab2-MARSS_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n\n\nLet's compare some other models.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# No cycles\nmod.list <- list(\n  Q = \"unconstrained\",\n  U = \"unequal\",\n  R = \"diagonal and equal\"\n)\nfit1.87 <- MARSS(dat87, model=mod.list, silent=TRUE)\n# Only lag 5 cycles\nmod.list <- list(\n  Q = \"unconstrained\",\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  D = \"unconstrained\",\n  d = covariates[5:6,]\n)\nfit5.87 <- MARSS(dat87, model=mod.list, silent=TRUE)\n# Cycles in the process\n# which doesn't really make sense for salmon since the cycles are age-structure cycles \n# which act like cycles in the observations\nmod.list <- list(\n  Q = \"unconstrained\",\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  C = \"unconstrained\",\n  c = covariates\n)\nfit6.87 <- MARSS(dat87, model=mod.list, silent=TRUE)\n```\n:::\n\n\n\n\nHmm model without cyles is much better (lower AICc). Even if we only have the 5 year cycles (`covariates[5:6,]`), the AICc is larger than for the models with cycles.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naic <- c(fit1.87$AICc, fit4.87$AICc, fit5.87$AICc, fit6.87$AICc)\naic-min(aic)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  0.00000 56.99612 11.66091 56.99461\n```\n\n\n:::\n:::\n\n\n\n\n## Resources\n\nChapter 7 MARSS models. ATSA Lab Book. <https://atsa-es.github.io/atsa-labs/chap-mss.html>\n\nChapter 8 MARSS models with covariate. ATSA Lab Book. <https://atsa-es.github.io/atsa-labs/chap-msscov.html>\n\nChapter 16 Modeling cyclic sockeye <https://atsa-es.github.io/atsa-labs/chap-cyclic-sockeye.html>\n",
    "supporting": [
      "Lab2-MARSS_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}