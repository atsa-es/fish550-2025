{"title":"Lab Intro","markdown":{"yaml":{"title":"Lab Intro","subtitle":"Lab 2 Analyzing multivariate salmon data","author":"E Holmes","date":"April 13, 2023","output":{"pdf_document":{"toc":"yes"},"html_document":{"code-folding":"yes","toc":"yes","toc_float":"yes"}}},"headingText":"Teams","containsRefs":false,"markdown":"\n\n```{r message=FALSE}\nlibrary(tidyverse)\noptions(dplyr.summarise.inform = FALSE)\n```\n\nFor this lab you will use multivariate auto-regressive state-space (MARSS) to analyze multivariate salmon data from the Columbia River. These data are noisy and gappy. They are estimates of total spawner abundance and might include hatchery spawners.\n\n\n1. Lower Columbia River Chinook: Zoe Rand (QERM), Emma Timmins-Schiffman (Genome Sci), Maria Kuruvilla (QERM)\n2. Lower Columbia River Steelhead: Eric French (Civil), Liz Elmstrom (SAFS), Terrance Wang (SAFS)\n3. Lower Columbia River Coho: Nick Chambers (SAFS), Karl Veggerby (SAFS), Miranda Mudge (Molecular & Cellular)\n4. Middle Columbia River Steelhead: Madison Shipley (SAFS), Dylan Hubl (Env & Forest Sci)\n\n## Lower Columbia River salmon spawner data\n\nThese data are from the [Coordinated Assessments Partnership (CAP) ](https://www.streamnet.org/cap/about-cap/) and downloaded using the [rCAX R client](https://nwfsc-math-bio.github.io/rCAX/) for the CAX (the CAP database) API. The data are saved in `Lab-2/Data_Images/columbia-river.rda`.\n\n```{r}\nload(here::here(\"Lab-2\", \"Data_Images\", \"columbia-river.rda\"))\n```\n\nThe data set has data for fi endangered and threatened ESU (Evolutionary Significant Units) in the Lower Columbia River.\n```{r}\nesu <- unique(columbia.river$esu_dps)\nesu\n```\n\n```{r echo=FALSE, out.width=\"50%\", fig.cap=\"Figure from ESA recovery plan for Lower Columbia River Coho salmon, Lower Columbia River Chinook salmon, Columbia River Chum salmon, and Lower Columbia River steelhead. 2013. NMFS NW Region.  https://repository.library.noaa.gov/view/noaa/16002\"}\nknitr::include_graphics(\"Data_Images/LCR-chinook-regions.png\")\n```\n\n### Data structure\n\nThe dataset has the following columns\n```{r}\ncolnames(columbia.river)\n```\n* species: Chinook, Coho, Steelhead\n* esu_dps: name of the ESU\n* majorpopgroup: biological major group\n* commonpopname: common population name, generally a stream or river\n* run: run-timing\n* spawningyear: the year that the spawners were counted on the spawning grounds\n* value: total (natural-born and hatchery-born) spawners on the spawning ground. Generally some type of redd-count expansion or some other stream count of spawners. Redd = a gravel nest.\n\n### Data plots\n\nLet's load one ESU and make a plot. Create a function.\n```{r}\nplotesu <- function(esuname){\n  df <- columbia.river %>% subset(esu_dps %in% esuname)\nggplot(df, aes(x=spawningyear, y=log(value), color=majorpopgroup)) + \n  geom_point(size=0.2, na.rm = TRUE) + \n  theme(strip.text.x = element_text(size = 3)) +\n  theme(axis.text.x = element_text(size = 5, angle = 90)) +\n  facet_wrap(~esapopname) +\n  ggtitle(paste0(esuname, collapse=\"\\n\"))\n}\n```\n\n```{r}\nplotesu(esu[3])\n```\n\n```{r}\nplotesu(esu[4])\n```\n\n```{r}\nplotesu(esu[5])\n```\n\n```{r}\nplotesu(esu[1])\n```\n\n```{r}\ndf <- columbia.river %>% subset(species == \"Chinook salmon\")\nggplot(df, aes(x=spawningyear, y=log(value), color=run)) + \n  geom_point(size=0.2, na.rm = TRUE) +\n  theme(strip.text.x = element_text(size = 3)) +\n  theme(axis.text.x = element_text(size = 5, angle = 90)) + \n  facet_wrap(~esapopname)\n```\n\n## Tasks for each group\n\n1. Create estimates of spawner abundance for all missing years and provide estimates of the decline from the historical abundance.\n\n2. Evaluate support for the major population groups. Are the populations in the groups more correlated than outside the groups?\n\n3. Evaluate the evidence of cycling in the data. *We will talk about how to do this on the Tuesday after lab.*\n\n\n### Tips\n\n**Simplify**\n\nIf your ESU has many populations, start with a smaller set of 4-7 populations.\n\n**Assumptions**\n\nYou can assume that `R=\"diagonal and equal\"` and `A=\"scaling\"`. Assume that \"historical\" means the earliest years available for your group.\n\n**States**\n\nYour abundance estimate is the \"x\" or \"state\" estimates. You can get this from\n```\nfit$states\n```\nor \n```\ntsSmooth(fit)\n```\nwhere `fit` is from `fit <- MARSS()`\n\n**plotting**\n\nEstimate of the mean of the spawner counts based on your x model.\n```\nautoplot(fit, plot.type=\"fitted.ytT\")\n```\n\n**diagnostics**\n```\nautoplot(fit, plot.type=\"residuals\")\n```\n\n### Address the following in your methods\n\n* Describe your assumptions about the x and how the data time series are related to x.\n\n   - How are the x and y (data) related? 1 x for 1 y or will you assume 1 x for all y or 1 x for each major population group? How will you choose? \n   - What will you assume about the U for the x's?\n   - What will you assume about the Q matrix?\n   \n* Write out your assumptions as different models **in matrix form**, fit each and then compare these with AIC or AICc.\n\n* Do your estimates differ depending on the assumptions you make about the structure of the data, i.e. you assumptions about the x's, Q, and U.\n\n## Sample code\n\nHere I show how I might analyze the Upper Columbia Steelhead data.\n\n```{r echo=FALSE, out.width=\"50%\", fig.cap=\"Figure from 2022 5-Year Review: Summary & Evaluation of Upper Columbia River Spring-run Chinook Salmon and Upper Columbia River Steelhead. NMFS. West Coast Region. https://doi.org/10.25923/p4w5-dp31\"}\nknitr::include_graphics(\"Data_Images/UCR-Steelhead-regions.png\")\n```\n\nSet up the data. We need the time series in a matrix with time across the columns.\n\nLoad the data.\n```{r}\nload(here::here(\"Lab-2\", \"Data_Images\", \"columbia-river.rda\"))\n```\n\nWrangle the data.\n```{r}\nlibrary(dplyr)\nesuname <- esu[2]\n\ndat <- columbia.river %>% \n  subset(esu_dps == esuname) %>% # get only this ESU\n  mutate(log.spawner = log(value)) %>% # create a column called log.spawner\n  select(esapopname, spawningyear, log.spawner) %>% # get just the columns that I need\n  pivot_wider(names_from = \"esapopname\", values_from = \"log.spawner\") %>% \n  column_to_rownames(var = \"spawningyear\") %>% # make the years rownames\n  as.matrix() %>% # turn into a matrix with year down the rows\n  t() # make time across the columns\n# MARSS complains if I don't do this\ndat[is.na(dat)] <- NA\n```\n\nClean up the row names\n```{r}\ntmp <- rownames(dat)\ntmp <- stringr::str_replace(tmp, \"Steelhead [(]Upper Columbia River DPS[)]\", \"\")\ntmp <- stringr::str_replace(tmp, \"River - summer\", \"\")\ntmp <- stringr::str_trim(tmp)\nrownames(dat) <- tmp\n```\n\nSpecify a model\n```{r}\nmod.list1 <- list(\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  Q = \"unconstrained\"\n)\n```\n\nFit the model. In this case, a BFGS algorithm is faster.\n```{r}\nlibrary(MARSS)\nfit1 <- MARSS(dat, model=mod.list1, method=\"BFGS\")\n```\n\nHmmmmm, the Q variance is so high that it perfectly fits the data. That doesn't seem right.\n```{r}\nautoplot(fit1, plot.type=\"fitted.ytT\")\n```\n\nLet's look at the corrplot. Interesting. The Methow and Entiat are almost perfectly correlated while the Entiat and Wenatchee are somewhat correlated. That makes sense if you look at a map.\n```{r}\nlibrary(corrplot)\nQ <- coef(fit1, type=\"matrix\")$Q\ncorrmat <- diag(1/sqrt(diag(Q))) %*% Q %*% diag(1/sqrt(diag(Q)))\ncorrplot(corrmat)\n```\n\nI need to use the EM algorithm (remove `method=\"BFGS\"`) because the BFGS algorithm doesn't allow constraints on the Q matrix.\n```{r}\nmod.list2 <- list(\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  Q = \"equalvarcov\"\n)\nfit2 <- MARSS(dat, model=mod.list2, control = list(maxit=1000))\n```\n\n```{r}\nautoplot(fit2, plot.type=\"fitted.ytT\")\n```\n\n\nNow I want try something different. I will treat the Methow-Okanogan as one state and the Entiat-Wenatchee as another. I'll let these be correlated together. Interesting, these two are estimated to be perfectly correlated.\n```{r}\nmod.list3 <- mod.list1\nmod.list3$Q <- \"unconstrained\"\nmod.list3$Z <- factor(c(\"ew\", \"mo\", \"mo\", \"ew\"))\nfit3 <- MARSS(dat, model = mod.list3)\nautoplot(fit3, plot.type=\"fitted.ytT\")\n```\n\nFinally, let's look at the AIC values. Fit1 was very flexible and can put a line through the data so I know I have at least one model in the set that can fit the data. Well, the most flexible model is the best. At this point, I'd like to look just at data after 1980 or so. I don't like the big dip that happened in the Wenatchee River. I'd want to talk to the biologists to find out what happened, especially because I know that there might be hatchery releases in this system.\n```{r}\naic <- c(fit1$AICc, fit2$AICc, fit3$AICc)\naic-min(aic)\n```\n\n### Including cycling\n\nLet's just look at the data after 1987 to eliminate that string of NAs in the 3 rivers.\n\n```{r}\ndat87 <- dat[,colnames(dat)>1987]\n```\n\nLet's look the acf to look for evidence of cycling. Due to the nature of their life-cycle where they tend to return back to their spawning grounds after a certain numbers of years, we might expect some cycling although steelhead aren't really known for this (unlike sockeye, chinook and pink).\n\nWell no obvious cycles.\n\n```{r}\npar(mfrow=c(2,2))\nfor(i in 1:4){\n  acf(dat87[i,], na.action=na.pass, main=rownames(dat87)[i])\n}\n```\n\nBut let's go through how we might include cycles. We are going to include cycles with frequency 3, 4, and 5, choosem to reflect steelhead returning after 3, 4 or 5 years.\n\n```{r}\nTT <- dim(dat87)[2] #number of time steps\ncovariates <- rbind(\n  forecast::fourier(ts(1:TT, freq=3), K=1) |> t(),\n  forecast::fourier(ts(1:TT, freq=4), K=1) |> t(),\n  forecast::fourier(ts(1:TT, freq=5), K=1) |> t()\n)\n```\n\nNow let's fit a model with these covariates. Let's analyze the populations separately, so Q is diagonal.\n```{r}\nmod.list4 <- list(\n  Q = \"unconstrained\",\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  D = \"unconstrained\",\n  d = covariates\n)\n```\n  \n```{r acf-entiat}\nfit4.87 <- MARSS(dat87, model=mod.list4)\n```\n\nLet's plot the estimates. `broom::tidy()` will get a data frame with the terms, estimates and CIs.\n```{r}\nlibrary(broom)\n# get all the parameter estimates for D\ndf <- tidy(fit4.87) %>%\n  subset(stringr::str_sub(term,1,1)==\"D\")\n# add a column with the river names\ndf$river <- as.factor(rep(rownames(dat87),nrow(covariates)))\n# add a column for the lag or frequency\nlags <- stringr::str_split(rownames(covariates), \"-\") %>% lapply(function(x){x[[2]]}) %>% unlist()\ndf$lag <- rep(lags, each=nrow(dat87))\n# add column for the type of fourier\ndf$type <- rep(rownames(covariates), each=nrow(dat87))\n```\n\nWe can then plot this. Interesting. Some support for 5 year cycles.\n```{r}\nggplot(df, aes(x=type, y=estimate, col=lag)) + \n  geom_point() +\n  geom_errorbar(aes(ymin=conf.low, ymax=conf.up), width=.2, position=position_dodge(.9)) +\n  geom_hline(yintercept = 0) +\n  facet_wrap(~river) +\n  ggtitle(\"The cycle estimates with CIs\")\n```\n\nLet's compare some other models.\n```{r}\n# No cycles\nmod.list <- list(\n  Q = \"unconstrained\",\n  U = \"unequal\",\n  R = \"diagonal and equal\"\n)\nfit1.87 <- MARSS(dat87, model=mod.list, silent=TRUE)\n# Only lag 5 cycles\nmod.list <- list(\n  Q = \"unconstrained\",\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  D = \"unconstrained\",\n  d = covariates[5:6,]\n)\nfit5.87 <- MARSS(dat87, model=mod.list, silent=TRUE)\n# Cycles in the process\n# which doesn't really make sense for salmon since the cycles are age-structure cycles \n# which act like cycles in the observations\nmod.list <- list(\n  Q = \"unconstrained\",\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  C = \"unconstrained\",\n  c = covariates\n)\nfit6.87 <- MARSS(dat87, model=mod.list, silent=TRUE)\n```\n\nHmm model without cyles is much better (lower AICc). Even if we only have the 5 year cycles (`covariates[5:6,]`), the AICc is larger than for the models with cycles.\n```{r}\naic <- c(fit1.87$AICc, fit4.87$AICc, fit5.87$AICc, fit6.87$AICc)\naic-min(aic)\n```\n\n## Resources\n\nChapter 7 MARSS models. ATSA Lab Book. <https://atsa-es.github.io/atsa-labs/chap-mss.html>\n\nChapter 8 MARSS models with covariate. ATSA Lab Book. <https://atsa-es.github.io/atsa-labs/chap-msscov.html>\n\nChapter 16 Modeling cyclic sockeye <https://atsa-es.github.io/atsa-labs/chap-cyclic-sockeye.html>\n","srcMarkdownNoYaml":"\n\n```{r message=FALSE}\nlibrary(tidyverse)\noptions(dplyr.summarise.inform = FALSE)\n```\n\nFor this lab you will use multivariate auto-regressive state-space (MARSS) to analyze multivariate salmon data from the Columbia River. These data are noisy and gappy. They are estimates of total spawner abundance and might include hatchery spawners.\n\n## Teams\n\n1. Lower Columbia River Chinook: Zoe Rand (QERM), Emma Timmins-Schiffman (Genome Sci), Maria Kuruvilla (QERM)\n2. Lower Columbia River Steelhead: Eric French (Civil), Liz Elmstrom (SAFS), Terrance Wang (SAFS)\n3. Lower Columbia River Coho: Nick Chambers (SAFS), Karl Veggerby (SAFS), Miranda Mudge (Molecular & Cellular)\n4. Middle Columbia River Steelhead: Madison Shipley (SAFS), Dylan Hubl (Env & Forest Sci)\n\n## Lower Columbia River salmon spawner data\n\nThese data are from the [Coordinated Assessments Partnership (CAP) ](https://www.streamnet.org/cap/about-cap/) and downloaded using the [rCAX R client](https://nwfsc-math-bio.github.io/rCAX/) for the CAX (the CAP database) API. The data are saved in `Lab-2/Data_Images/columbia-river.rda`.\n\n```{r}\nload(here::here(\"Lab-2\", \"Data_Images\", \"columbia-river.rda\"))\n```\n\nThe data set has data for fi endangered and threatened ESU (Evolutionary Significant Units) in the Lower Columbia River.\n```{r}\nesu <- unique(columbia.river$esu_dps)\nesu\n```\n\n```{r echo=FALSE, out.width=\"50%\", fig.cap=\"Figure from ESA recovery plan for Lower Columbia River Coho salmon, Lower Columbia River Chinook salmon, Columbia River Chum salmon, and Lower Columbia River steelhead. 2013. NMFS NW Region.  https://repository.library.noaa.gov/view/noaa/16002\"}\nknitr::include_graphics(\"Data_Images/LCR-chinook-regions.png\")\n```\n\n### Data structure\n\nThe dataset has the following columns\n```{r}\ncolnames(columbia.river)\n```\n* species: Chinook, Coho, Steelhead\n* esu_dps: name of the ESU\n* majorpopgroup: biological major group\n* commonpopname: common population name, generally a stream or river\n* run: run-timing\n* spawningyear: the year that the spawners were counted on the spawning grounds\n* value: total (natural-born and hatchery-born) spawners on the spawning ground. Generally some type of redd-count expansion or some other stream count of spawners. Redd = a gravel nest.\n\n### Data plots\n\nLet's load one ESU and make a plot. Create a function.\n```{r}\nplotesu <- function(esuname){\n  df <- columbia.river %>% subset(esu_dps %in% esuname)\nggplot(df, aes(x=spawningyear, y=log(value), color=majorpopgroup)) + \n  geom_point(size=0.2, na.rm = TRUE) + \n  theme(strip.text.x = element_text(size = 3)) +\n  theme(axis.text.x = element_text(size = 5, angle = 90)) +\n  facet_wrap(~esapopname) +\n  ggtitle(paste0(esuname, collapse=\"\\n\"))\n}\n```\n\n```{r}\nplotesu(esu[3])\n```\n\n```{r}\nplotesu(esu[4])\n```\n\n```{r}\nplotesu(esu[5])\n```\n\n```{r}\nplotesu(esu[1])\n```\n\n```{r}\ndf <- columbia.river %>% subset(species == \"Chinook salmon\")\nggplot(df, aes(x=spawningyear, y=log(value), color=run)) + \n  geom_point(size=0.2, na.rm = TRUE) +\n  theme(strip.text.x = element_text(size = 3)) +\n  theme(axis.text.x = element_text(size = 5, angle = 90)) + \n  facet_wrap(~esapopname)\n```\n\n## Tasks for each group\n\n1. Create estimates of spawner abundance for all missing years and provide estimates of the decline from the historical abundance.\n\n2. Evaluate support for the major population groups. Are the populations in the groups more correlated than outside the groups?\n\n3. Evaluate the evidence of cycling in the data. *We will talk about how to do this on the Tuesday after lab.*\n\n\n### Tips\n\n**Simplify**\n\nIf your ESU has many populations, start with a smaller set of 4-7 populations.\n\n**Assumptions**\n\nYou can assume that `R=\"diagonal and equal\"` and `A=\"scaling\"`. Assume that \"historical\" means the earliest years available for your group.\n\n**States**\n\nYour abundance estimate is the \"x\" or \"state\" estimates. You can get this from\n```\nfit$states\n```\nor \n```\ntsSmooth(fit)\n```\nwhere `fit` is from `fit <- MARSS()`\n\n**plotting**\n\nEstimate of the mean of the spawner counts based on your x model.\n```\nautoplot(fit, plot.type=\"fitted.ytT\")\n```\n\n**diagnostics**\n```\nautoplot(fit, plot.type=\"residuals\")\n```\n\n### Address the following in your methods\n\n* Describe your assumptions about the x and how the data time series are related to x.\n\n   - How are the x and y (data) related? 1 x for 1 y or will you assume 1 x for all y or 1 x for each major population group? How will you choose? \n   - What will you assume about the U for the x's?\n   - What will you assume about the Q matrix?\n   \n* Write out your assumptions as different models **in matrix form**, fit each and then compare these with AIC or AICc.\n\n* Do your estimates differ depending on the assumptions you make about the structure of the data, i.e. you assumptions about the x's, Q, and U.\n\n## Sample code\n\nHere I show how I might analyze the Upper Columbia Steelhead data.\n\n```{r echo=FALSE, out.width=\"50%\", fig.cap=\"Figure from 2022 5-Year Review: Summary & Evaluation of Upper Columbia River Spring-run Chinook Salmon and Upper Columbia River Steelhead. NMFS. West Coast Region. https://doi.org/10.25923/p4w5-dp31\"}\nknitr::include_graphics(\"Data_Images/UCR-Steelhead-regions.png\")\n```\n\nSet up the data. We need the time series in a matrix with time across the columns.\n\nLoad the data.\n```{r}\nload(here::here(\"Lab-2\", \"Data_Images\", \"columbia-river.rda\"))\n```\n\nWrangle the data.\n```{r}\nlibrary(dplyr)\nesuname <- esu[2]\n\ndat <- columbia.river %>% \n  subset(esu_dps == esuname) %>% # get only this ESU\n  mutate(log.spawner = log(value)) %>% # create a column called log.spawner\n  select(esapopname, spawningyear, log.spawner) %>% # get just the columns that I need\n  pivot_wider(names_from = \"esapopname\", values_from = \"log.spawner\") %>% \n  column_to_rownames(var = \"spawningyear\") %>% # make the years rownames\n  as.matrix() %>% # turn into a matrix with year down the rows\n  t() # make time across the columns\n# MARSS complains if I don't do this\ndat[is.na(dat)] <- NA\n```\n\nClean up the row names\n```{r}\ntmp <- rownames(dat)\ntmp <- stringr::str_replace(tmp, \"Steelhead [(]Upper Columbia River DPS[)]\", \"\")\ntmp <- stringr::str_replace(tmp, \"River - summer\", \"\")\ntmp <- stringr::str_trim(tmp)\nrownames(dat) <- tmp\n```\n\nSpecify a model\n```{r}\nmod.list1 <- list(\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  Q = \"unconstrained\"\n)\n```\n\nFit the model. In this case, a BFGS algorithm is faster.\n```{r}\nlibrary(MARSS)\nfit1 <- MARSS(dat, model=mod.list1, method=\"BFGS\")\n```\n\nHmmmmm, the Q variance is so high that it perfectly fits the data. That doesn't seem right.\n```{r}\nautoplot(fit1, plot.type=\"fitted.ytT\")\n```\n\nLet's look at the corrplot. Interesting. The Methow and Entiat are almost perfectly correlated while the Entiat and Wenatchee are somewhat correlated. That makes sense if you look at a map.\n```{r}\nlibrary(corrplot)\nQ <- coef(fit1, type=\"matrix\")$Q\ncorrmat <- diag(1/sqrt(diag(Q))) %*% Q %*% diag(1/sqrt(diag(Q)))\ncorrplot(corrmat)\n```\n\nI need to use the EM algorithm (remove `method=\"BFGS\"`) because the BFGS algorithm doesn't allow constraints on the Q matrix.\n```{r}\nmod.list2 <- list(\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  Q = \"equalvarcov\"\n)\nfit2 <- MARSS(dat, model=mod.list2, control = list(maxit=1000))\n```\n\n```{r}\nautoplot(fit2, plot.type=\"fitted.ytT\")\n```\n\n\nNow I want try something different. I will treat the Methow-Okanogan as one state and the Entiat-Wenatchee as another. I'll let these be correlated together. Interesting, these two are estimated to be perfectly correlated.\n```{r}\nmod.list3 <- mod.list1\nmod.list3$Q <- \"unconstrained\"\nmod.list3$Z <- factor(c(\"ew\", \"mo\", \"mo\", \"ew\"))\nfit3 <- MARSS(dat, model = mod.list3)\nautoplot(fit3, plot.type=\"fitted.ytT\")\n```\n\nFinally, let's look at the AIC values. Fit1 was very flexible and can put a line through the data so I know I have at least one model in the set that can fit the data. Well, the most flexible model is the best. At this point, I'd like to look just at data after 1980 or so. I don't like the big dip that happened in the Wenatchee River. I'd want to talk to the biologists to find out what happened, especially because I know that there might be hatchery releases in this system.\n```{r}\naic <- c(fit1$AICc, fit2$AICc, fit3$AICc)\naic-min(aic)\n```\n\n### Including cycling\n\nLet's just look at the data after 1987 to eliminate that string of NAs in the 3 rivers.\n\n```{r}\ndat87 <- dat[,colnames(dat)>1987]\n```\n\nLet's look the acf to look for evidence of cycling. Due to the nature of their life-cycle where they tend to return back to their spawning grounds after a certain numbers of years, we might expect some cycling although steelhead aren't really known for this (unlike sockeye, chinook and pink).\n\nWell no obvious cycles.\n\n```{r}\npar(mfrow=c(2,2))\nfor(i in 1:4){\n  acf(dat87[i,], na.action=na.pass, main=rownames(dat87)[i])\n}\n```\n\nBut let's go through how we might include cycles. We are going to include cycles with frequency 3, 4, and 5, choosem to reflect steelhead returning after 3, 4 or 5 years.\n\n```{r}\nTT <- dim(dat87)[2] #number of time steps\ncovariates <- rbind(\n  forecast::fourier(ts(1:TT, freq=3), K=1) |> t(),\n  forecast::fourier(ts(1:TT, freq=4), K=1) |> t(),\n  forecast::fourier(ts(1:TT, freq=5), K=1) |> t()\n)\n```\n\nNow let's fit a model with these covariates. Let's analyze the populations separately, so Q is diagonal.\n```{r}\nmod.list4 <- list(\n  Q = \"unconstrained\",\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  D = \"unconstrained\",\n  d = covariates\n)\n```\n  \n```{r acf-entiat}\nfit4.87 <- MARSS(dat87, model=mod.list4)\n```\n\nLet's plot the estimates. `broom::tidy()` will get a data frame with the terms, estimates and CIs.\n```{r}\nlibrary(broom)\n# get all the parameter estimates for D\ndf <- tidy(fit4.87) %>%\n  subset(stringr::str_sub(term,1,1)==\"D\")\n# add a column with the river names\ndf$river <- as.factor(rep(rownames(dat87),nrow(covariates)))\n# add a column for the lag or frequency\nlags <- stringr::str_split(rownames(covariates), \"-\") %>% lapply(function(x){x[[2]]}) %>% unlist()\ndf$lag <- rep(lags, each=nrow(dat87))\n# add column for the type of fourier\ndf$type <- rep(rownames(covariates), each=nrow(dat87))\n```\n\nWe can then plot this. Interesting. Some support for 5 year cycles.\n```{r}\nggplot(df, aes(x=type, y=estimate, col=lag)) + \n  geom_point() +\n  geom_errorbar(aes(ymin=conf.low, ymax=conf.up), width=.2, position=position_dodge(.9)) +\n  geom_hline(yintercept = 0) +\n  facet_wrap(~river) +\n  ggtitle(\"The cycle estimates with CIs\")\n```\n\nLet's compare some other models.\n```{r}\n# No cycles\nmod.list <- list(\n  Q = \"unconstrained\",\n  U = \"unequal\",\n  R = \"diagonal and equal\"\n)\nfit1.87 <- MARSS(dat87, model=mod.list, silent=TRUE)\n# Only lag 5 cycles\nmod.list <- list(\n  Q = \"unconstrained\",\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  D = \"unconstrained\",\n  d = covariates[5:6,]\n)\nfit5.87 <- MARSS(dat87, model=mod.list, silent=TRUE)\n# Cycles in the process\n# which doesn't really make sense for salmon since the cycles are age-structure cycles \n# which act like cycles in the observations\nmod.list <- list(\n  Q = \"unconstrained\",\n  U = \"unequal\",\n  R = \"diagonal and equal\",\n  C = \"unconstrained\",\n  c = covariates\n)\nfit6.87 <- MARSS(dat87, model=mod.list, silent=TRUE)\n```\n\nHmm model without cyles is much better (lower AICc). Even if we only have the 5 year cycles (`covariates[5:6,]`), the AICc is larger than for the models with cycles.\n```{r}\naic <- c(fit1.87$AICc, fit4.87$AICc, fit5.87$AICc, fit6.87$AICc)\naic-min(aic)\n```\n\n## Resources\n\nChapter 7 MARSS models. ATSA Lab Book. <https://atsa-es.github.io/atsa-labs/chap-mss.html>\n\nChapter 8 MARSS models with covariate. ATSA Lab Book. <https://atsa-es.github.io/atsa-labs/chap-msscov.html>\n\nChapter 16 Modeling cyclic sockeye <https://atsa-es.github.io/atsa-labs/chap-cyclic-sockeye.html>\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":{"pdf_document":{"toc":"yes"},"html_document":{"code-folding":"yes","toc":"yes","toc_float":"yes"}},"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"code-overflow":"wrap","engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"Lab2-MARSS.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.39","theme":"cosmo","number-depth":0,"title":"Lab Intro","subtitle":"Lab 2 Analyzing multivariate salmon data","author":"E Holmes","date":"April 13, 2023"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}